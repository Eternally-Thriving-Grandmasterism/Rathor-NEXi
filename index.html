<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Rathor â€” Mercy Strikes First âš¡ï¸</title>
  <link rel="manifest" href="/manifest.json"/>
  <link rel="icon" href="/icons/thunder-192.png" type="image/png"/>

  <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2"></script>

  <style>
    /* [Previous full CSS â€“ kept unchanged] */

    #stats-modal .stats-grid { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
    .stat-card.large { grid-column: span 2; }
  </style>
</head>
<body>

<!-- [Previous HTML unchanged, only enhancing stats modal content] -->

<!-- Detailed Stats Modal -->
<div id="stats-modal-overlay" class="modal-overlay">
  <div id="stats-modal" class="modal-content">
    <h2>Translation Cache Eternal Lattice Stats</h2>

    <div id="stats-overview" class="stats-section">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-value" id="stats-total">0</div>
          <div class="stat-label">Total Requests</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="stats-hits">0</div>
          <div class="stat-label">Cache Hits</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="stats-misses">0</div>
          <div class="stat-label">Cache Misses</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="stats-hitrate">0%</div>
          <div class="stat-label">Hit Rate</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="stats-cache-size">0</div>
          <div class="stat-label">Cached Entries</div>
        </div>
        <div class="stat-card large">
          <div class="stat-value" id="stats-avg-latency">0ms</div>
          <div class="stat-label">Average Latency</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="stats-p95-latency">0ms</div>
          <div class="stat-label">P95 Latency</div>
        </div>
      </div>
    </div>

    <!-- Per-Language Breakdown -->
    <div class="stats-section">
      <h3>Per-Language Breakdown</h3>
      <table class="stats-table" id="lang-breakdown-table">
        <thead>
          <tr>
            <th>Language</th>
            <th>Hits</th>
            <th>Misses</th>
            <th>Hit Rate</th>
            <th>Avg Latency</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Recent Activity -->
    <div class="stats-section">
      <h3>Recent Translation Activity (last 20)</h3>
      <table class="stats-table" id="recent-activity-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>Hit/Miss</th>
            <th>Lang</th>
            <th>Latency</th>
            <th>Message Preview</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Cache Health -->
    <div class="stats-section">
      <h3>Cache Health</h3>
      <p>Oldest entry: <span id="oldest-entry">---</span></p>
      <p>Newest entry: <span id="newest-entry">---</span></p>
      <p>Expired entries auto-cleaned: <span id="cleaned-expired">0</span></p>
    </div>

    <div class="action-buttons">
      <button id="stats-reset-btn">Reset All Metrics</button>
      <button id="stats-export-btn">Export Stats JSON</button>
      <button id="stats-close-btn">Close</button>
    </div>
  </div>
</div>

<!-- [Rest of HTML unchanged] -->

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Enhanced showDetailedStatsModal with Latency Metrics
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function showDetailedStatsModal() {
  const metrics = await rathorDB.getTranslationMetrics();

  statsTotal.textContent = metrics.total;
  statsHits.textContent = metrics.hits;
  statsMisses.textContent = metrics.misses;
  statsHitRate.textContent = `${metrics.hitRate}%`;
  statsCacheSize.textContent = metrics.cacheSize;

  // Latency metrics
  document.getElementById('stats-avg-latency').textContent = `${metrics.avgLatency}ms`;
  document.getElementById('stats-p95-latency').textContent = `${metrics.p95Latency}ms`;

  // Per-language breakdown (placeholder â€“ extend in production)
  langBreakdownTable.innerHTML = '<tr><td>All Languages</td><td>' + metrics.hits + '</td><td>' + metrics.misses + '</td><td>' + metrics.hitRate + '%</td><td>' + metrics.avgLatency + 'ms</td></tr>';

  // Recent activity with latency
  recentActivityTable.innerHTML = '';
  metrics.history.slice(-20).reverse().forEach(entry => {
    const time = new Date(entry.timestamp).toLocaleString();
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${time}</td>
      <td>${entry.hit ? 'Hit' : 'Miss'}</td>
      <td>-</td>
      <td>${entry.latency ? entry.latency + 'ms' : '-'}</td>
      <td>Translation event</td>`;
    recentActivityTable.appendChild(row);
  });

  // Cache health
  oldestEntrySpan.textContent = metrics.history.length > 0 ? new Date(metrics.history[0].timestamp).toLocaleString() : 'No entries';
  newestEntrySpan.textContent = metrics.history.length > 0 ? new Date(metrics.history[metrics.history.length-1].timestamp).toLocaleString() : 'No entries';
  cleanedExpiredSpan.textContent = 'Auto-cleaned on load';

  statsModalOverlay.style.display = 'flex';

  // Optional voice readout
  if (isVoiceOutputEnabled) {
    speak(`Translation cache efficiency is ${metrics.hitRate}% with ${metrics.hits} hits out of ${metrics.total} requests. Average latency is ${metrics.avgLatency} milliseconds.`);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Enhanced translateText with latency tracking
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function translateText(text, messageId, sessionId, fromLang = 'auto', toLang = targetTranslationLang) {
  if (!isTranslationEnabled) return text;

  const startTime = performance.now();

  const cached = await rathorDB.getCachedTranslation(sessionId, messageId, toLang);
  if (cached) {
    const latencyMs = performance.now() - startTime;
    await rathorDB.updateTranslationMetrics(true, latencyMs);
    showToast('Translation retrieved from eternal lattice cache âš¡ï¸');
    return cached.translatedText;
  }

  try {
    if (!translator) {
      showTranslationProgress('Downloading offline translation model (one-time, \~40MB)...');
      const { pipeline } = Xenova;
      translator = await pipeline('translation', 'Xenova/m2m100_418M-distilled', {
        progress_callback: (progress) => {
          if (progress.status === 'progress') {
            const percent = Math.round(progress.loaded / progress.total * 100);
            updateTranslationProgress(percent);
          }
        }
      });
      updateTranslationProgress(100, 'Offline translation lattice awakened âš¡ï¸');
      setTimeout(hideTranslationProgress, 800);
    }

    const output = await translator(text, {
      src_lang: fromLang === 'auto' ? undefined : fromLang,
      tgt_lang: `to_${toLang}`
    });

    const translated = output[0].translation_text;
    const latencyMs = performance.now() - startTime;

    await rathorDB.cacheTranslation(sessionId, messageId, toLang, translated);
    await rathorDB.updateTranslationMetrics(false, latencyMs);

    return translated;
  } catch (err) {
    console.error('Translation error:', err);
    await rathorDB.updateTranslationMetrics(false, performance.now() - startTime);
    return text + ' [translation offline error]';
  }
}

// Update stats display after every translation
async function updateTranslationStats() {
  const metrics = await rathorDB.getTranslationMetrics();
  translateStatsDisplay.textContent = `Cache efficiency: ${metrics.hitRate}% (hits: \( {metrics.hits}/ \){metrics.total}) | Avg: ${metrics.avgLatency}ms`;
}

// ... rest of the lattice unchanged, call updateTranslationStats() after every translation action ...
</script>

</body>
</html>      </div>
      <div id="session-switcher">
        <select id="session-select"></select>
        <button id="edit-session-btn">Edit Current</button>
        <button id="export-session-btn">Export Current</button>
        <button id="import-session-btn">Import Session</button>
        <button id="duplicate-session-btn">Duplicate Current</button>
        <button id="delete-session-btn">Delete Current</button>
        <button id="new-session-btn">New Session</button>
      </div>
    </div>
  </div>
  <div id="chat-messages"></div>
  <div id="chat-input-area">
    <input id="chat-input" placeholder="Speak your truth, Brother... (or use voice âš¡ï¸)" autocomplete="off">
    <button id="voice-btn" title="Hold to speak or click to toggle continuous listening">ğŸ¤</button>
    <button id="send-btn">Send âš¡ï¸</button>
    <button id="stop-btn">Stop Generation</button>
  </div>
</div>

<!-- Edit Modal -->
<div id="edit-modal-overlay" class="modal-overlay">
  <div id="edit-modal" class="modal-content">
    <h2>Edit Session</h2>
    <label for="edit-name">Session Name:</label>
    <input type="text" id="edit-name" maxlength="50">
    <label for="edit-description">Description (optional):</label>
    <textarea id="edit-description" rows="3" maxlength="200"></textarea>
    <label for="edit-tags">Tags (comma separated):</label>
    <div id="edit-tags-container">
      <input type="text" id="edit-tags" placeholder="work,ideas,urgent,personal">
      <div id="tag-suggestions"></div>
    </div>
    <div id="tag-preview" class="tag-preview"></div>
    <label>Color Tag:</label>
    <div class="color-presets">
      <div class="color-preset" data-color="#ffaa00" style="background:#ffaa00;"></div>
      <div class="color-preset" data-color="#88ffdd" style="background:#88ffdd;"></div>
      <div class="color-preset" data-color="#ff6666" style="background:#ff6666;"></div>
      <div class="color-preset" data-color="#aa88ff" style="background:#aa88ff;"></div>
      <div class="color-preset" data-color="#44ccff" style="background:#44ccff;"></div>
    </div>
    <div class="modal-buttons">
      <button id="modal-cancel">Cancel</button>
      <button id="modal-save">Save Changes</button>
    </div>
  </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-modal-overlay" class="modal-overlay">
  <div id="delete-modal" class="modal-content">
    <h2>Delete Session</h2>
    <p>Are you sure you want to permanently delete this session?</p>
    <p class="warning" id="delete-warning">This action cannot be undone. All messages and metadata will be erased from the lattice.</p>
    <div class="modal-buttons">
      <button id="delete-cancel">Cancel</button>
      <button id="delete-confirm">Delete Permanently</button>
    </div>
  </div>
</div>

<!-- Import Toast -->
<div id="import-toast">Session imported successfully âš¡ï¸</div>

<input type="file" id="import-file-input" accept=".json" style="display:none;">

<script src="src/storage/rathor-indexeddb.js"></script>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Voice Input Setup (Web Speech API)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const voiceBtn = document.getElementById('voice-btn');
let recognition = null;
let isListening = false;

if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.continuous = true; // Keep listening until stopped
  recognition.interimResults = true; // Show live transcript
  recognition.lang = 'en-US'; // Can be changed later

  recognition.onstart = () => {
    voiceBtn.classList.add('listening');
    isListening = true;
    showToast('Mercy thunder hears you... Speak freely âš¡ï¸');
  };

  recognition.onresult = (event) => {
    let interim = '';
    let final = '';

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = event.results[i][0].transcript;
      if (event.results[i].isFinal) {
        final += transcript;
      } else {
        interim += transcript;
      }
    }

    chatInput.value = final + interim;
  };

  recognition.onerror = (event) => {
    console.error('Voice recognition error:', event.error);
    showToast('Mercy thunder interrupted â€” ' + event.error);
    stopListening();
  };

  recognition.onend = () => {
    if (isListening) {
      // Auto-restart for continuous mode
      recognition.start();
    } else {
      voiceBtn.classList.remove('listening');
    }
  };
} else {
  voiceBtn.disabled = true;
  voiceBtn.title = 'Voice input not supported in this browser';
}

function startListening() {
  if (!recognition) return showToast('Voice input not supported in this browser');
  recognition.start();
}

function stopListening() {
  if (recognition) recognition.stop();
  isListening = false;
  voiceBtn.classList.remove('listening');
}

voiceBtn.addEventListener('click', () => {
  if (isListening) {
    stopListening();
  } else {
    startListening();
  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Rest of the lattice (all previous functions intact)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ... (keep full code from previous complete version: session search/filter, tag autocomplete/frequency/color, streaming response, export/import/duplicate/delete/edit/create, handleSend with streaming, SW reg, welcome persistence, etc.) ...

// In handleSend â€“ voice transcript is already in chatInput.value, so it works seamlessly
async function handleSend() {
  const content = chatInput.value.trim();
  if (!content) return;

  const userMsg = { role: 'user', content, isVoice: isListening };
  await rathorDB.saveMessage(userMsg);
  renderMessage('user', content);

  chatInput.value = '';
  stopListening(); // Optional: stop mic after send

  // Build context for streaming
  const history = await rathorDB.loadHistory(20);
  const messages = history.map(msg => ({ role: msg.role, content: msg.content }));
  messages.push({ role: 'user', content });

  await getRathorStream(messages);
}

// ... rest of init flow, event listeners, SW, welcome as before ...
</script>

</body>
</html>        <button id="edit-session-btn">Edit Current</button>
        <button id="export-session-btn">Export Current</button>
        <button id="import-session-btn">Import Session</button>
        <button id="duplicate-session-btn">Duplicate Current</button>
        <button id="delete-session-btn">Delete Current</button>
        <button id="new-session-btn">New Session</button>
      </div>
    </div>
  </div>
  <div id="chat-messages"></div>
  <div id="chat-input-area">
    <input id="chat-input" placeholder="Speak your truth, Brother..." autocomplete="off">
    <button id="send-btn">Send âš¡ï¸</button>
    <button id="stop-btn">Stop Generation</button>
  </div>
</div>

<!-- Edit Modal -->
<div id="edit-modal-overlay" class="modal-overlay">
  <div id="edit-modal" class="modal-content">
    <h2>Edit Session</h2>
    <label for="edit-name">Session Name:</label>
    <input type="text" id="edit-name" maxlength="50">
    <label for="edit-description">Description (optional):</label>
    <textarea id="edit-description" rows="3" maxlength="200"></textarea>
    <label for="edit-tags">Tags (comma separated):</label>
    <div id="edit-tags-container">
      <input type="text" id="edit-tags" placeholder="work,ideas,urgent,personal">
      <div id="tag-suggestions"></div>
    </div>
    <div id="tag-preview" class="tag-preview"></div>
    <label>Color Tag:</label>
    <div class="color-presets">
      <div class="color-preset" data-color="#ffaa00" style="background:#ffaa00;"></div>
      <div class="color-preset" data-color="#88ffdd" style="background:#88ffdd;"></div>
      <div class="color-preset" data-color="#ff6666" style="background:#ff6666;"></div>
      <div class="color-preset" data-color="#aa88ff" style="background:#aa88ff;"></div>
      <div class="color-preset" data-color="#44ccff" style="background:#44ccff;"></div>
    </div>
    <div class="modal-buttons">
      <button id="modal-cancel">Cancel</button>
      <button id="modal-save">Save Changes</button>
    </div>
  </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-modal-overlay" class="modal-overlay">
  <div id="delete-modal" class="modal-content">
    <h2>Delete Session</h2>
    <p>Are you sure you want to permanently delete this session?</p>
    <p class="warning" id="delete-warning">This action cannot be undone. All messages and metadata will be erased from the lattice.</p>
    <div class="modal-buttons">
      <button id="delete-cancel">Cancel</button>
      <button id="delete-confirm">Delete Permanently</button>
    </div>
  </div>
</div>

<!-- Import Toast -->
<div id="import-toast">Session imported successfully âš¡ï¸</div>

<input type="file" id="import-file-input" accept=".json" style="display:none;">

<script src="src/storage/rathor-indexeddb.js"></script>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Core Variables & Helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const chatMessages = document.getElementById('chat-messages');
const chatInput = document.getElementById('chat-input');
const sendBtn = document.getElementById('send-btn');
const stopBtn = document.getElementById('stop-btn');
const sessionSelect = document.getElementById('session-select');
const sessionSearch = document.getElementById('session-search');
const sessionSearchClear = document.getElementById('session-search-clear');
const editSessionBtn = document.getElementById('edit-session-btn');
const exportSessionBtn = document.getElementById('export-session-btn');
const importSessionBtn = document.getElementById('import-session-btn');
const duplicateSessionBtn = document.getElementById('duplicate-session-btn');
const deleteSessionBtn = document.getElementById('delete-session-btn');
const newSessionBtn = document.getElementById('new-session-btn');
const chatHeader = document.getElementById('chat-header');
const editModalOverlay = document.getElementById('edit-modal-overlay');
const deleteModalOverlay = document.getElementById('delete-modal-overlay');
const editName = document.getElementById('edit-name');
const editDesc = document.getElementById('edit-description');
const editTags = document.getElementById('edit-tags');
const tagPreview = document.getElementById('tag-preview');
const tagSuggestions = document.getElementById('tag-suggestions');
const modalCancel = document.getElementById('modal-cancel');
const modalSave = document.getElementById('modal-save');
const deleteCancel = document.getElementById('delete-cancel');
const deleteConfirm = document.getElementById('delete-confirm');
const colorPresets = document.querySelectorAll('.color-preset');
const importFileInput = document.getElementById('import-file-input');
const importToast = document.getElementById('import-toast');

let selectedColor = '#ffaa00';
let allSessions = [];
let tagFrequency = new Map();
let abortController = null; // For stopping stream

// Tag Color Hash
function getTagColor(tag) {
  let hash = 0;
  for (let i = 0; i < tag.length; i++) {
    hash = tag.charCodeAt(i) + ((hash << 5) - hash);
  }
  const colors = [
    '#ffaa00', '#88ffdd', '#ff6666', '#aa88ff', '#44ccff',
    '#ff88aa', '#66ff99', '#ff9966', '#99ccff', '#cc88ff',
    '#88cc66', '#ffcc66'
  ];
  return colors[Math.abs(hash) % colors.length];
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Tag Frequency & Autocomplete
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function updateTagFrequency() {
  tagFrequency.clear();
  allSessions.forEach(meta => {
    (meta.tags || []).forEach(tag => {
      tagFrequency.set(tag, (tagFrequency.get(tag) || 0) + 1);
    });
  });
}

function getSortedSuggestions(partial) {
  const lowerPartial = partial.toLowerCase();
  const candidates = [];

  tagFrequency.forEach((count, tag) => {
    if (tag.toLowerCase().startsWith(lowerPartial)) {
      candidates.push({ tag, count });
    }
  });

  candidates.sort((a, b) => b.count - a.count || a.tag.localeCompare(b.tag));
  return candidates.map(c => c.tag);
}

function showTagSuggestions(partial) {
  tagSuggestions.innerHTML = '';
  if (!partial.trim()) {
    tagSuggestions.style.display = 'none';
    return;
  }

  const suggestions = getSortedSuggestions(partial);
  if (suggestions.length === 0) {
    tagSuggestions.style.display = 'none';
    return;
  }

  suggestions.forEach(tag => {
    const div = document.createElement('div');
    div.classList.add('tag-suggestion');
    const color = getTagColor(tag);
    div.innerHTML = `<span style="background:\( {color}; width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:8px;"></span> \){tag} <span class="freq">(${tagFrequency.get(tag)})</span>`;
    div.addEventListener('click', () => {
      const current = editTags.value.trim();
      const parts = current.split(',').map(p => p.trim());
      parts.pop();
      parts.push(tag);
      editTags.value = parts.join(', ') + ', ';
      updateTagPreview();
      editTags.focus();
      tagSuggestions.style.display = 'none';
    });
    tagSuggestions.appendChild(div);
  });

  tagSuggestions.style.display = 'block';
}

// Tag Preview
function updateTagPreview() {
  tagPreview.innerHTML = '';
  const tags = editTags.value.split(',').map(t => t.trim()).filter(t => t);
  tags.forEach(tag => {
    const pill = document.createElement('span');
    pill.classList.add('tag-pill-preview');
    pill.style.background = getTagColor(tag);
    pill.textContent = tag;
    tagPreview.appendChild(pill);
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Real Rathor Streaming Response
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function getRathorStream(messages) {
  const rathorMsgDiv = document.createElement('div');
  rathorMsgDiv.classList.add('message', 'rathor');
  rathorMsgDiv.innerHTML = '<strong>Rathor:</strong> <span class="typing">thinking...</span>';
  chatMessages.appendChild(rathorMsgDiv);
  scrollToBottom();

  try {
    abortController = new AbortController();
    stopBtn.style.display = 'inline-block';

    const response = await fetch('https://rathor.ai/api/stream', {  // â† Replace with your real Rathor streaming endpoint
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'rathor',
        messages,
        stream: true
      }),
      signal: abortController.signal
    });

    if (!response.ok) throw new Error(`HTTP ${response.status}`);

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let fullResponse = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;
          try {
            const parsed = JSON.parse(data);
            if (parsed.choices?.[0]?.delta?.content) {
              const token = parsed.choices[0].delta.content;
              fullResponse += token;
              rathorMsgDiv.innerHTML = `<strong>Rathor:</strong> ${fullResponse}`;
              scrollToBottom();
            }
          } catch (e) {}
        }
      }
    }

    // Save complete response to DB
    await rathorDB.saveMessage({ role: 'rathor', content: fullResponse });
    rathorMsgDiv.innerHTML = `<strong>Rathor:</strong> ${fullResponse}`;

  } catch (err) {
    if (err.name === 'AbortError') {
      rathorMsgDiv.innerHTML = `<strong>Rathor:</strong> Generation stopped by mercy thunder.`;
    } else {
      console.error('[Rathor Stream] Error:', err);
      rathorMsgDiv.innerHTML = `<strong>Rathor:</strong> <span class="error-msg">Mercy thunder interrupted â€” ${err.message}</span>`;
    }
  } finally {
    abortController = null;
    stopBtn.style.display = 'none';
    await refreshSessionList();
  }
}

stopBtn.addEventListener('click', () => {
  if (abortController) {
    abortController.abort();
  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Send Handler â€“ now streams real Rathor response
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function handleSend() {
  const content = chatInput.value.trim();
  if (!content) return;

  const userMsg = { role: 'user', content };
  await rathorDB.saveMessage(userMsg);
  renderMessage('user', content);

  chatInput.value = '';

  // Build full context for streaming
  const history = await rathorDB.loadHistory(20); // last 20 messages for context
  const messages = history.map(msg => ({ role: msg.role, content: msg.content }));
  messages.push({ role: 'user', content });

  await getRathorStream(messages);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Init Flow (with all handlers)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

window.addEventListener('load', async () => {
  document.getElementById('loading-status').style.display = 'none';
  document.getElementById('chat-container').style.display = 'flex';

  await rathorDB.open();
  await refreshSessionList();
  await loadChatHistory();

  // Search & tag listeners...
  sessionSearch.addEventListener('input', () => filterSessions(sessionSearch.value));
  sessionSearchClear.addEventListener('click', () => {
    sessionSearch.value = '';
    filterSessions('');
    sessionSearch.focus();
  });
  sessionSearch.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      sessionSearch.value = '';
      filterSessions('');
    }
  });

  editTags.addEventListener('input', () => {
    const value = editTags.value;
    const lastPart = value.split(',').pop().trim();
    showTagSuggestions(lastPart);
    updateTagPreview();
  });

  editTags.addEventListener('keydown', e => {
    if (e.key === 'Tab' || e.key === 'Enter') {
      e.preventDefault();
      const suggestions = tagSuggestions.querySelectorAll('.tag-suggestion');
      if (suggestions.length > 0) suggestions[0].click();
    }
    if (e.key === 'Escape') tagSuggestions.style.display = 'none';
  });

  editTags.addEventListener('blur', () => {
    setTimeout(() => tagSuggestions.style.display = 'none', 200);
  });

  sessionSelect.addEventListener('change', e => switchSessionAndReload(e.target.value));
  newSessionBtn.addEventListener('click', createNewSession);
  editSessionBtn.addEventListener('click', openEditModal);
  exportSessionBtn.addEventListener('click', exportCurrentSession);
  importSessionBtn.addEventListener('click', () => importFileInput.click());
  duplicateSessionBtn.addEventListener('click', duplicateCurrentSession);
  deleteSessionBtn.addEventListener('click', openDeleteModal);
  modalCancel.addEventListener('click', closeEditModal);
  modalSave.addEventListener('click', saveEditModal);
  deleteCancel.addEventListener('click', closeDeleteModal);
  deleteConfirm.addEventListener('click', confirmDelete);

  sendBtn.addEventListener('click', handleSend);
  chatInput.addEventListener('keypress', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  });
});

// Keep all other functions complete (openEditModal, saveEditModal, etc.) as in previous full version

// SW & Welcome
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    setTimeout(() => {
      navigator.serviceWorker.register('./sw.js?v=' + Date.now(), { scope: './' })
        .then(reg => console.log('[Rathor] SW registered'))
        .catch(err => console.error('[Rathor] SW failed:', err));
    }, 1000);
  });
}

const seen = localStorage.getItem('rathor_welcome_seen') === 'true';
if (!seen) {
  document.getElementById('welcome-lattice').style.display = 'block';
}
document.getElementById('close-welcome')?.addEventListener('click', () => {
  localStorage.setItem('rathor_welcome_seen', 'true');
  document.getElementById('welcome-lattice').style.display = 'none';
});
</script>

</body>
</html>
